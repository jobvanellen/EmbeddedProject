
EmbeddedProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000334  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000003a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000a  00800060  00800060  000003a8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000003a8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000003d8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c0  00000000  00000000  00000414  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000714  00000000  00000000  000004d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000250  00000000  00000000  00000be8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000031f  00000000  00000000  00000e38  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000021c  00000000  00000000  00001158  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000042d  00000000  00000000  00001374  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000471  00000000  00000000  000017a1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  00001c12  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 46 01 	jmp	0x28c	; 0x28c <__vector_1>
   8:	0c 94 64 01 	jmp	0x2c8	; 0x2c8 <__vector_2>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 82 01 	jmp	0x304	; 0x304 <__vector_10>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	aa 36       	cpi	r26, 0x6A	; 106
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 41 01 	call	0x282	; 0x282 <main>
  74:	0c 94 98 01 	jmp	0x330	; 0x330 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <wait>:

//always call this to maintain speed control OBSOLETE
void dynamicUpdate(){
	//amend motor speeds
	if(curSpeed_right < desiredSpeed_right) curPower_right++;
	if(curSpeed_left < desiredSpeed_left) curPower_left++;
  7c:	2f e7       	ldi	r18, 0x7F	; 127
  7e:	8a e1       	ldi	r24, 0x1A	; 26
  80:	96 e0       	ldi	r25, 0x06	; 6
  82:	21 50       	subi	r18, 0x01	; 1
  84:	80 40       	sbci	r24, 0x00	; 0
  86:	90 40       	sbci	r25, 0x00	; 0
  88:	e1 f7       	brne	.-8      	; 0x82 <wait+0x6>
  8a:	00 c0       	rjmp	.+0      	; 0x8c <wait+0x10>
  8c:	00 00       	nop
  8e:	2f e7       	ldi	r18, 0x7F	; 127
  90:	8a e1       	ldi	r24, 0x1A	; 26
  92:	96 e0       	ldi	r25, 0x06	; 6
  94:	21 50       	subi	r18, 0x01	; 1
  96:	80 40       	sbci	r24, 0x00	; 0
  98:	90 40       	sbci	r25, 0x00	; 0
  9a:	e1 f7       	brne	.-8      	; 0x94 <wait+0x18>
  9c:	00 c0       	rjmp	.+0      	; 0x9e <wait+0x22>
  9e:	00 00       	nop
	if(curSpeed_right > desiredSpeed_right) curPower_right--;
  a0:	2f e7       	ldi	r18, 0x7F	; 127
  a2:	8a e1       	ldi	r24, 0x1A	; 26
  a4:	96 e0       	ldi	r25, 0x06	; 6
  a6:	21 50       	subi	r18, 0x01	; 1
  a8:	80 40       	sbci	r24, 0x00	; 0
  aa:	90 40       	sbci	r25, 0x00	; 0
  ac:	e1 f7       	brne	.-8      	; 0xa6 <wait+0x2a>
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <wait+0x34>
  b0:	00 00       	nop
  b2:	08 95       	ret

000000b4 <setMotorPower>:
  b4:	83 3d       	cpi	r24, 0xD3	; 211
  b6:	08 f0       	brcs	.+2      	; 0xba <setMotorPower+0x6>
  b8:	82 ed       	ldi	r24, 0xD2	; 210
	if(curSpeed_left > desiredSpeed_left) curPower_left--;
  ba:	63 3d       	cpi	r22, 0xD3	; 211
  bc:	08 f0       	brcs	.+2      	; 0xc0 <setMotorPower+0xc>
  be:	62 ed       	ldi	r22, 0xD2	; 210
  c0:	8a bd       	out	0x2a, r24	; 42
  c2:	68 bd       	out	0x28, r22	; 40
  c4:	08 95       	ret

000000c6 <setMotorPowerDynamic>:
  c6:	cf 93       	push	r28
  c8:	df 93       	push	r29
  ca:	90 91 68 00 	lds	r25, 0x0068
  ce:	89 17       	cp	r24, r25
  d0:	91 f1       	breq	.+100    	; 0x136 <setMotorPowerDynamic+0x70>
  d2:	d6 2f       	mov	r29, r22
  d4:	c8 2f       	mov	r28, r24
  d6:	20 91 69 00 	lds	r18, 0x0069
	setMotorPower(curPower_right, curPower_left);
  da:	62 17       	cp	r22, r18
  dc:	61 f1       	breq	.+88     	; 0x136 <setMotorPowerDynamic+0x70>
  de:	c9 17       	cp	r28, r25
  e0:	18 f4       	brcc	.+6      	; 0xe8 <setMotorPowerDynamic+0x22>
  e2:	91 50       	subi	r25, 0x01	; 1
	
	if(curPower_left || curPower_right)
  e4:	90 93 68 00 	sts	0x0068, r25
  e8:	90 91 68 00 	lds	r25, 0x0068
  ec:	9c 17       	cp	r25, r28
  ee:	18 f4       	brcc	.+6      	; 0xf6 <setMotorPowerDynamic+0x30>
  f0:	9f 5f       	subi	r25, 0xFF	; 255
  f2:	90 93 68 00 	sts	0x0068, r25
	TCCR1A = (1 << WGM11) | (1 << COM1A1) | (1 << COM1B1);
  f6:	d2 17       	cp	r29, r18
  f8:	18 f4       	brcc	.+6      	; 0x100 <setMotorPowerDynamic+0x3a>
	else
	TCCR1A = 0;
  fa:	21 50       	subi	r18, 0x01	; 1
}
  fc:	20 93 69 00 	sts	0x0069, r18
 100:	90 91 69 00 	lds	r25, 0x0069
 104:	9d 17       	cp	r25, r29
 106:	18 f4       	brcc	.+6      	; 0x10e <setMotorPowerDynamic+0x48>
 108:	9f 5f       	subi	r25, 0xFF	; 255
 10a:	90 93 69 00 	sts	0x0069, r25
 10e:	60 91 69 00 	lds	r22, 0x0069
 112:	80 91 68 00 	lds	r24, 0x0068
 116:	0e 94 5a 00 	call	0xb4	; 0xb4 <setMotorPower>
 11a:	8f e1       	ldi	r24, 0x1F	; 31
 11c:	9e e4       	ldi	r25, 0x4E	; 78
 11e:	01 97       	sbiw	r24, 0x01	; 1
 120:	f1 f7       	brne	.-4      	; 0x11e <setMotorPowerDynamic+0x58>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 122:	00 c0       	rjmp	.+0      	; 0x124 <setMotorPowerDynamic+0x5e>
 124:	00 00       	nop
	else
	desiredSpeed_left = speedLeft;
}

void setMotorPowerDynamic(uint8_t right_des, uint8_t left_des){
	while(right_des != curPower_right && left_des != curPower_left){
 126:	90 91 68 00 	lds	r25, 0x0068
 12a:	c9 17       	cp	r28, r25
 12c:	21 f0       	breq	.+8      	; 0x136 <setMotorPowerDynamic+0x70>
 12e:	20 91 69 00 	lds	r18, 0x0069
 132:	d2 13       	cpse	r29, r18
 134:	d4 cf       	rjmp	.-88     	; 0xde <setMotorPowerDynamic+0x18>
		if(left_des < curPower_left) curPower_left--;
		if(left_des > curPower_left) curPower_left++;
		setMotorPower(curPower_right, curPower_left);
		_delay_ms(10);
	}
}
 136:	df 91       	pop	r29
 138:	cf 91       	pop	r28
 13a:	08 95       	ret

0000013c <setMotorDirection>:
	snelheid --;
}

//sets the direction of the left and right motor respectively, only call when speed = 0
void setMotorDirection(uint8_t left, uint8_t right){
	if(left)
 13c:	88 23       	and	r24, r24
 13e:	11 f0       	breq	.+4      	; 0x144 <setMotorDirection+0x8>
		PORTC |= DIR_L;
 140:	aa 9a       	sbi	0x15, 2	; 21
 142:	01 c0       	rjmp	.+2      	; 0x146 <setMotorDirection+0xa>
	else
		PORTC &= ~DIR_L;
 144:	aa 98       	cbi	0x15, 2	; 21
		
	if(right)
 146:	66 23       	and	r22, r22
 148:	11 f0       	breq	.+4      	; 0x14e <setMotorDirection+0x12>
		PORTC |= DIR_R;
 14a:	ab 9a       	sbi	0x15, 3	; 21
 14c:	01 c0       	rjmp	.+2      	; 0x150 <setMotorDirection+0x14>
	else
		PORTC &= ~DIR_R;
 14e:	ab 98       	cbi	0x15, 3	; 21
		
	curDirection_right = right;
 150:	60 93 64 00 	sts	0x0064, r22
	curDirection_left = left;
 154:	80 93 65 00 	sts	0x0065, r24
 158:	08 95       	ret

0000015a <init>:
	for(int i = 0; i < 3; i++)
		_delay_ms(250);
}

void init(){
	cli();
 15a:	f8 94       	cli
	
	//set pins I/O
	//DDRA = 0x00; //00000000
	//DDRB =  //11011011
	DDRC= DIR_R | DIR_L; //111111xx
 15c:	8c e0       	ldi	r24, 0x0C	; 12
 15e:	84 bb       	out	0x14, r24	; 20
	DDRD = MOTOR_R | MOTOR_L; //01110010
 160:	80 e3       	ldi	r24, 0x30	; 48
 162:	81 bb       	out	0x11, r24	; 17
	
	//initialize PWM (timer1)
	TCCR1A = (0 << WGM10) | (1 << WGM11) | (1 << COM1A1) | (1 << COM1B1);
 164:	82 ea       	ldi	r24, 0xA2	; 162
 166:	8f bd       	out	0x2f, r24	; 47
	TCCR1B =  (1 << WGM13) | (0 << WGM12) | (1 << CS10);
 168:	81 e1       	ldi	r24, 0x11	; 17
 16a:	8e bd       	out	0x2e, r24	; 46
	ICR1 = 210; 
 16c:	82 ed       	ldi	r24, 0xD2	; 210
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	97 bd       	out	0x27, r25	; 39
 172:	86 bd       	out	0x26, r24	; 38
	OCR1AL = 0;
 174:	1a bc       	out	0x2a, r1	; 42
	OCR1BL = 0;
 176:	18 bc       	out	0x28, r1	; 40
	setMotorDirection(FWD, FWD);
 178:	60 e0       	ldi	r22, 0x00	; 0
 17a:	80 e0       	ldi	r24, 0x00	; 0
 17c:	0e 94 9e 00 	call	0x13c	; 0x13c <setMotorDirection>
	
	//initialize interrupts: int0 links, int1 rechts
	MCUCR = (0 << ISC11) | (1 << ISC10) | (0 << ISC01) | (1 << ISC00);
 180:	85 e0       	ldi	r24, 0x05	; 5
 182:	85 bf       	out	0x35, r24	; 53
	GICR = (1 << INT2) | (1 << INT1);
 184:	80 ea       	ldi	r24, 0xA0	; 160
 186:	8b bf       	out	0x3b, r24	; 59

	//initialiseer Timer 0: 100µs cycle
	TCCR0 =   (0 << WGM00) | (1 << WGM01)				//Counter mode:CTC Top:OCR0 Update:Immediate TOV0flag set on:MAX
 188:	8a e0       	ldi	r24, 0x0A	; 10
 18a:	83 bf       	out	0x33, r24	; 51
			| (0 << COM00) | (0 << COM01)				//normal port OC0 disconnected
			| (0 << CS02)  | (1 << CS01) | (0 << CS00); //8bit prescaler
	OCR0  = 99;											//output compare register
 18c:	83 e6       	ldi	r24, 0x63	; 99
 18e:	8c bf       	out	0x3c, r24	; 60
		
	sei();
 190:	78 94       	sei
 192:	08 95       	ret

00000194 <rijVooruit>:
	curDirection_right = right;
	curDirection_left = left;
}

void rijVooruit(){
	if(!(curDirection_left == FWD && curDirection_right == FWD)){//zet snelheid naar 0 en verander de richting als dat nodig is
 194:	80 91 65 00 	lds	r24, 0x0065
 198:	81 11       	cpse	r24, r1
 19a:	04 c0       	rjmp	.+8      	; 0x1a4 <rijVooruit+0x10>
 19c:	80 91 64 00 	lds	r24, 0x0064
 1a0:	88 23       	and	r24, r24
 1a2:	41 f0       	breq	.+16     	; 0x1b4 <rijVooruit+0x20>
		setMotorPowerDynamic(0, 0);
 1a4:	60 e0       	ldi	r22, 0x00	; 0
 1a6:	80 e0       	ldi	r24, 0x00	; 0
 1a8:	0e 94 63 00 	call	0xc6	; 0xc6 <setMotorPowerDynamic>
		setMotorDirection(FWD,FWD);		
 1ac:	60 e0       	ldi	r22, 0x00	; 0
 1ae:	80 e0       	ldi	r24, 0x00	; 0
 1b0:	0e 94 9e 00 	call	0x13c	; 0x13c <setMotorDirection>
	}
	setMotorPowerDynamic(snelheid, snelheid);
 1b4:	80 91 67 00 	lds	r24, 0x0067
 1b8:	68 2f       	mov	r22, r24
 1ba:	0e 94 63 00 	call	0xc6	; 0xc6 <setMotorPowerDynamic>
 1be:	08 95       	ret

000001c0 <rijAchteruit>:
}

void rijAchteruit(){
	if(!(curDirection_left == BWD && curDirection_right == BWD)){//zet snelheid naar 0 en verander de richting als dat nodig is
 1c0:	80 91 65 00 	lds	r24, 0x0065
 1c4:	81 30       	cpi	r24, 0x01	; 1
 1c6:	21 f4       	brne	.+8      	; 0x1d0 <rijAchteruit+0x10>
 1c8:	80 91 64 00 	lds	r24, 0x0064
 1cc:	81 30       	cpi	r24, 0x01	; 1
 1ce:	41 f0       	breq	.+16     	; 0x1e0 <rijAchteruit+0x20>
		setMotorPowerDynamic(0, 0);
 1d0:	60 e0       	ldi	r22, 0x00	; 0
 1d2:	80 e0       	ldi	r24, 0x00	; 0
 1d4:	0e 94 63 00 	call	0xc6	; 0xc6 <setMotorPowerDynamic>
		setMotorDirection(BWD,BWD);		
 1d8:	61 e0       	ldi	r22, 0x01	; 1
 1da:	81 e0       	ldi	r24, 0x01	; 1
 1dc:	0e 94 9e 00 	call	0x13c	; 0x13c <setMotorDirection>
	}
	setMotorPowerDynamic(snelheid, snelheid);
 1e0:	80 91 67 00 	lds	r24, 0x0067
 1e4:	68 2f       	mov	r22, r24
 1e6:	0e 94 63 00 	call	0xc6	; 0xc6 <setMotorPowerDynamic>
 1ea:	08 95       	ret

000001ec <naarLinks>:
}

void naarLinks(){
	if(!(curDirection_left == BWD && curDirection_right == FWD)){//zet snelheid naar 0 en verander de richting als dat nodig is
 1ec:	80 91 65 00 	lds	r24, 0x0065
 1f0:	81 30       	cpi	r24, 0x01	; 1
 1f2:	21 f4       	brne	.+8      	; 0x1fc <naarLinks+0x10>
 1f4:	80 91 64 00 	lds	r24, 0x0064
 1f8:	88 23       	and	r24, r24
 1fa:	41 f0       	breq	.+16     	; 0x20c <naarLinks+0x20>
		setMotorPowerDynamic(0, 0);
 1fc:	60 e0       	ldi	r22, 0x00	; 0
 1fe:	80 e0       	ldi	r24, 0x00	; 0
 200:	0e 94 63 00 	call	0xc6	; 0xc6 <setMotorPowerDynamic>
		setMotorDirection(BWD,FWD);
 204:	60 e0       	ldi	r22, 0x00	; 0
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	0e 94 9e 00 	call	0x13c	; 0x13c <setMotorDirection>
	}
	setMotorPowerDynamic(snelheid, snelheid);
 20c:	80 91 67 00 	lds	r24, 0x0067
 210:	68 2f       	mov	r22, r24
 212:	0e 94 63 00 	call	0xc6	; 0xc6 <setMotorPowerDynamic>
 216:	08 95       	ret

00000218 <naarRechts>:
	//TODO gebruik kompas
}

void naarRechts(){
	if(!(curDirection_left == FWD && curDirection_right == BWD)){//zet snelheid naar 0 en verander de richting als dat nodig is
 218:	80 91 65 00 	lds	r24, 0x0065
 21c:	81 11       	cpse	r24, r1
 21e:	04 c0       	rjmp	.+8      	; 0x228 <naarRechts+0x10>
 220:	80 91 64 00 	lds	r24, 0x0064
 224:	81 30       	cpi	r24, 0x01	; 1
 226:	41 f0       	breq	.+16     	; 0x238 <naarRechts+0x20>
		setMotorPowerDynamic(0, 0);
 228:	60 e0       	ldi	r22, 0x00	; 0
 22a:	80 e0       	ldi	r24, 0x00	; 0
 22c:	0e 94 63 00 	call	0xc6	; 0xc6 <setMotorPowerDynamic>
		setMotorDirection(FWD,BWD);
 230:	61 e0       	ldi	r22, 0x01	; 1
 232:	80 e0       	ldi	r24, 0x00	; 0
 234:	0e 94 9e 00 	call	0x13c	; 0x13c <setMotorDirection>
	}
	setMotorPowerDynamic(snelheid, snelheid);
 238:	80 91 67 00 	lds	r24, 0x0067
 23c:	68 2f       	mov	r22, r24
 23e:	0e 94 63 00 	call	0xc6	; 0xc6 <setMotorPowerDynamic>
 242:	08 95       	ret

00000244 <testCycle>:
    }
	return(0);
}

void testCycle(){
	wait(2);
 244:	82 e0       	ldi	r24, 0x02	; 2
 246:	0e 94 3e 00 	call	0x7c	; 0x7c <wait>
	rijVooruit();
 24a:	0e 94 ca 00 	call	0x194	; 0x194 <rijVooruit>
	
	wait(2);
 24e:	82 e0       	ldi	r24, 0x02	; 2
 250:	0e 94 3e 00 	call	0x7c	; 0x7c <wait>
	naarLinks();
 254:	0e 94 f6 00 	call	0x1ec	; 0x1ec <naarLinks>
	
	wait(2);
 258:	82 e0       	ldi	r24, 0x02	; 2
 25a:	0e 94 3e 00 	call	0x7c	; 0x7c <wait>
	rijAchteruit();	
 25e:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <rijAchteruit>
	
	wait(2);
 262:	82 e0       	ldi	r24, 0x02	; 2
 264:	0e 94 3e 00 	call	0x7c	; 0x7c <wait>
	naarRechts();
 268:	0e 94 0c 01 	call	0x218	; 0x218 <naarRechts>
	
	if(snelheid > 210)
 26c:	80 91 67 00 	lds	r24, 0x0067
 270:	83 3d       	cpi	r24, 0xD3	; 211
 272:	18 f0       	brcs	.+6      	; 0x27a <testCycle+0x36>
		snelheid = 0;
 274:	10 92 67 00 	sts	0x0067, r1
 278:	08 95       	ret
	else
		snelheid += 25;
 27a:	87 5e       	subi	r24, 0xE7	; 231
 27c:	80 93 67 00 	sts	0x0067, r24
 280:	08 95       	ret

00000282 <main>:
uint8_t motorDistanceTotal_left = 0;
uint8_t motorDistanceTotal_right = 0;

int main(void)
{	
	init();
 282:	0e 94 ad 00 	call	0x15a	; 0x15a <init>
    while (1) 
    {
		testCycle();
 286:	0e 94 22 01 	call	0x244	; 0x244 <testCycle>
    }
 28a:	fd cf       	rjmp	.-6      	; 0x286 <main+0x4>

0000028c <__vector_1>:
float getTotalDistance(){
	return getDistanceByInterrupts((motorDistanceTotal_right + motorDistanceTotal_left)/2);
}

//external interrupt int0 left motor sensor
ISR (INT0_vect){
 28c:	1f 92       	push	r1
 28e:	0f 92       	push	r0
 290:	0f b6       	in	r0, 0x3f	; 63
 292:	0f 92       	push	r0
 294:	11 24       	eor	r1, r1
 296:	8f 93       	push	r24
 298:	9f 93       	push	r25
	motorDistance_left++;	//increment the amount of interrupts on the left side
 29a:	80 91 63 00 	lds	r24, 0x0063
 29e:	8f 5f       	subi	r24, 0xFF	; 255
 2a0:	80 93 63 00 	sts	0x0063, r24

	if(curDirection_right == curDirection_left)//if the car is not rotating increment the total distance
 2a4:	90 91 64 00 	lds	r25, 0x0064
 2a8:	80 91 65 00 	lds	r24, 0x0065
 2ac:	98 13       	cpse	r25, r24
 2ae:	05 c0       	rjmp	.+10     	; 0x2ba <__vector_1+0x2e>
		motorDistanceTotal_left++;
 2b0:	80 91 61 00 	lds	r24, 0x0061
 2b4:	8f 5f       	subi	r24, 0xFF	; 255
 2b6:	80 93 61 00 	sts	0x0061, r24
}
 2ba:	9f 91       	pop	r25
 2bc:	8f 91       	pop	r24
 2be:	0f 90       	pop	r0
 2c0:	0f be       	out	0x3f, r0	; 63
 2c2:	0f 90       	pop	r0
 2c4:	1f 90       	pop	r1
 2c6:	18 95       	reti

000002c8 <__vector_2>:

//external interrupt int1 right motor sensor
ISR (INT1_vect){
 2c8:	1f 92       	push	r1
 2ca:	0f 92       	push	r0
 2cc:	0f b6       	in	r0, 0x3f	; 63
 2ce:	0f 92       	push	r0
 2d0:	11 24       	eor	r1, r1
 2d2:	8f 93       	push	r24
 2d4:	9f 93       	push	r25
	motorDistance_right++;	//increment the amount of interrupts on the right side
 2d6:	80 91 62 00 	lds	r24, 0x0062
 2da:	8f 5f       	subi	r24, 0xFF	; 255
 2dc:	80 93 62 00 	sts	0x0062, r24

	if(curDirection_right == curDirection_left)//if the car is not rotating increment the total distance
 2e0:	90 91 64 00 	lds	r25, 0x0064
 2e4:	80 91 65 00 	lds	r24, 0x0065
 2e8:	98 13       	cpse	r25, r24
 2ea:	05 c0       	rjmp	.+10     	; 0x2f6 <__vector_2+0x2e>
		motorDistanceTotal_right++;
 2ec:	80 91 60 00 	lds	r24, 0x0060
 2f0:	8f 5f       	subi	r24, 0xFF	; 255
 2f2:	80 93 60 00 	sts	0x0060, r24
}
 2f6:	9f 91       	pop	r25
 2f8:	8f 91       	pop	r24
 2fa:	0f 90       	pop	r0
 2fc:	0f be       	out	0x3f, r0	; 63
 2fe:	0f 90       	pop	r0
 300:	1f 90       	pop	r1
 302:	18 95       	reti

00000304 <__vector_10>:

//timer interrupt for calc purposes
ISR (TIMER0_COMP_vect){
 304:	1f 92       	push	r1
 306:	0f 92       	push	r0
 308:	0f b6       	in	r0, 0x3f	; 63
 30a:	0f 92       	push	r0
 30c:	11 24       	eor	r1, r1
 30e:	8f 93       	push	r24
	
	if(ms_timer++ >= 9) {//1 interrupt per ms
 310:	80 91 66 00 	lds	r24, 0x0066
 314:	89 30       	cpi	r24, 0x09	; 9
 316:	20 f4       	brcc	.+8      	; 0x320 <__vector_10+0x1c>
 318:	8f 5f       	subi	r24, 0xFF	; 255
 31a:	80 93 66 00 	sts	0x0066, r24
 31e:	02 c0       	rjmp	.+4      	; 0x324 <__vector_10+0x20>
		if(update_timer++ > 2){
			dynamicUpdate();
			update_timer = 0;
		}*/
		
		ms_timer = 0;
 320:	10 92 66 00 	sts	0x0066, r1
	}
 324:	8f 91       	pop	r24
 326:	0f 90       	pop	r0
 328:	0f be       	out	0x3f, r0	; 63
 32a:	0f 90       	pop	r0
 32c:	1f 90       	pop	r1
 32e:	18 95       	reti

00000330 <_exit>:
 330:	f8 94       	cli

00000332 <__stop_program>:
 332:	ff cf       	rjmp	.-2      	; 0x332 <__stop_program>
